# 架构设计

## 概述

ZLCoro 是一个高性能的 C++20 协程框架，专为构建异步服务器应用而设计。本文档描述了核心架构和设计决策。

## 系统架构

### 分层设计

```
┌──────────────────────────────────────────────┐
│             应用层                            │
├──────────────────────────────────────────────┤
│          同步原语层                           │
│  (Mutex, Channel, WaitGroup, Semaphore)      │
├──────────────────────────────────────────────┤
│          异步 I/O 层                          │
│  (Epoll, Socket, Buffer, EventLoop)          │
├──────────────────────────────────────────────┤
│          调度器层                             │
│  (ThreadPool, IOScheduler, Timer)            │
├──────────────────────────────────────────────┤
│        协程基础设施层                         │
│  (Task, Promise, Awaiter, Generator)         │
├──────────────────────────────────────────────┤
│          操作系统层                           │
│      (Linux, Epoll, Threads)                 │
└──────────────────────────────────────────────┘
```

## 核心组件

### 1. 协程基础设施

#### Task<T>

提供 RAII 语义和类型安全返回值的基础协程类型。

**核心特性：**
- 显式恢复控制的惰性求值
- 通过模板参数提供类型安全的返回值
- 通过 RAII 自动管理资源
- 支持异常传播
- 通过 co_await 可组合

**设计：**
```cpp
template<typename T>
class Task {
    struct promise_type {
        Task get_return_object();
        std::suspend_always initial_suspend() noexcept;
        std::suspend_always final_suspend() noexcept;
        void unhandled_exception();
        void return_value(T value);  // void 类型使用 return_void()
    };
    
    // Awaiter 接口
    bool await_ready() const noexcept;
    std::coroutine_handle<> await_suspend(std::coroutine_handle<>);
    T await_resume();
};
```

#### Generator<T>

基于迭代器的协程，用于惰性值生成。

**使用场景：**
- 惰性序列生成
- 流处理
- 迭代算法

### 2. 调度器

#### 工作窃取线程池调度器

**设计原则：**
- 每个工作线程使用无锁工作窃取队列
- 本地任务 LIFO 执行（缓存友好）
- 远程队列 FIFO 窃取（减少竞争）
- 动态负载均衡

**实现：**
- 每线程工作队列最小化锁竞争
- 随机化窃取减少惊群效应
- 任务优先级支持延迟敏感操作

**性能特征：**
- 任务提交：均摊 O(1)
- 任务窃取：O(1)
- 可扩展性：与 CPU 核心数线性扩展

#### I/O 调度器

**设计：**
- 基于 Epoll 的事件循环
- 单次事件模式实现精确控制
- 边缘触发实现高性能
- 与线程池集成处理 CPU 密集型任务

**事件处理：**
```
1. epoll_wait() 阻塞直到事件就绪
2. 获取就绪的文件描述符
3. 恢复关联的协程
4. 协程处理 I/O，可能再次挂起
```

### 3. 异步 I/O

#### Socket 抽象

**非阻塞操作：**
```cpp
class AsyncSocket {
    Task<size_t> read(char* buf, size_t len);
    Task<size_t> write(const char* buf, size_t len);
    Task<void> connect(const Address& addr);
    Task<AsyncSocket> accept();
};
```

**零拷贝优化：**
- 文件传输使用 sendfile()
- 共享缓冲池
- 分散-聚集 I/O

#### 缓冲区管理

**设计：**
- 自动扩展的环形缓冲区
- 读写索引跟踪
- 内存池集成进行分配
- 共享缓冲区的写时复制

### 4. 同步原语

#### 协程 Mutex

**无锁快速路径：**
- 无竞争获取使用原子 CAS
- 仅在竞争时使用等待队列
- 支持 RAII 锁保护

**实现：**
```cpp
class Mutex {
    std::atomic<bool> locked_;
    std::queue<std::coroutine_handle<>> waiters_;
    
public:
    Task<void> lock();
    void unlock();
};
```

#### Channel<T>

**多生产者多消费者队列：**
- 缓冲和无缓冲模式
- 队列满/空时协程挂起
- 关闭语义用于优雅停机

**使用场景：**
- 生产者-消费者模式
- 管道处理
- 消息传递

### 5. 定时器系统

#### 时间轮实现

**分层时间轮：**
- 4 个时间轮：毫秒、秒、分钟、小时
- O(1) 定时器插入和删除
- 高效处理大量定时器

**精度：**
- 毫秒级粒度
- 惰性级联减少开销

## 内存管理

### 协程帧分配

**堆分配：**
- 编译器在堆上分配协程帧
- 通过重载 operator new/delete 可定制
- 与内存池集成提高效率

### 对象池

**目的：**
- 减少分配开销
- 提高缓存局部性
- 最小化内存碎片

**策略：**
- 线程本地自由列表
- 批量分配/释放
- 按大小类别隔离

## 错误处理

### 异常支持

异常在协程边界自然传播：
- 在 promise_type::unhandled_exception() 中捕获
- 存储在 promise 对象中
- 在 await_resume() 中重新抛出

### 错误码

对于性能关键路径，Result<T, E> 类型提供：
- 零开销错误处理
- 显式错误检查
- 可组合的错误传播

## 性能优化

### 缓存优化

1. **LIFO 任务执行**：热数据保留在缓存中
2. **数据结构对齐**：防止伪共享
3. **内存布局**：将频繁访问的数据放在一起

### 无锁算法

1. **工作窃取队列**：单生产者无锁
2. **原子操作**：用于简单状态转换
3. **RCU 模式**：用于读密集型工作负载

### 零拷贝 I/O

1. **直接内核绕过**：适用场景
2. **缓冲区共享**：最小化数据拷贝
3. **分散-聚集**：高效的向量 I/O

## 可扩展性

### 垂直扩展

- 高效使用所有 CPU 核心
- NUMA 感知调度（未来）
- 延迟敏感任务的 CPU 亲和性

### 水平扩展

- 为分布式部署而设计
- 状态可外部化
- RPC 网络协议支持

## 测试策略

### 单元测试

- Google Test 框架
- 组件级隔离
- 模拟依赖进行受控测试

### 集成测试

- 端到端场景
- 并发执行压力测试
- 故障注入测试

### 性能测试

- Google Benchmark 框架
- 延迟百分位跟踪（p50、p99、p999）
- 吞吐量测量
- 与行业标准对比

## 未来增强

1. **io_uring 支持**：Linux 下一代异步 I/O
2. **NUMA 感知**：更好的多插槽可扩展性
3. **分布式协调**：服务网格集成
4. **高级分析**：内置性能监控

---

该架构为构建高性能异步应用提供了坚实基础，同时保持了代码清晰性和可维护性。
