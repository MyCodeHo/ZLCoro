# ZLCoro 性能基准测试# 性能基准测试



本文档描述 ZLCoro 的性能目标、测试方法和当前结果。本文档定义了 ZLCoro 组件的性能基准测试计划和测试方法。随着项目开发，测试结果将持续更新。



## 性能目标## 测试环境



### 协程性能测试将在以下环境进行：

- 协程创建：< 100ns

- 协程切换：< 50ns- **CPU**: 待更新

- 内存开销：< 2KB/协程- **内存**: 待更新

- 并发协程数：100 万+- **操作系统**: 待更新

- **编译器**: GCC/Clang with -O3 优化

### I/O 性能- **内核**: 待更新

- 文件 I/O 吞吐量：> 1GB/s

- 网络 I/O 吞吐量：> 10GB/s## 测试方法论

- 并发连接数：100 万+

- QPS：100 万+### 基准测试工具



## 测试环境- **Google Benchmark**: 用于微基准测试

- **自定义测试框架**: 用于集成测试

**推荐配置**:- **perf**: 用于 CPU 性能分析

- CPU: Intel Core i7 或更好- **valgrind**: 用于内存分析

- 内存: 16GB+

- 操作系统: Ubuntu 20.04+### 测试流程

- 编译器: GCC 10+ 或 Clang 12+

- 优化级别: -O31. **预热期**: 10 秒

2. **测量期**: 60 秒

## 测试方法3. **重复次数**: 10 次运行

4. **结果统计**: 取中位数

### 基准测试工具5. **误差范围**: 记录 p50/p99 百分位



使用 Google Benchmark 进行微基准测试：### 可重现性



```bash所有基准测试可通过以下命令重现：

cd build

cmake -DCMAKE_BUILD_TYPE=Release ..```bash

make benchmarks -j$(nproc)cd build

./benchmarks/benchmark_namecmake -DCMAKE_BUILD_TYPE=Release ..

```make benchmarks

./benchmarks/coroutine_bench

### 测试流程./benchmarks/scheduler_bench

./benchmarks/io_bench

1. **预热**: 10秒```

2. **测量**: 60秒

3. **重复**: 10次## 协程原语测试

4. **统计**: 中位数/p99

### Task 创建和销毁

## 基准测试

测试目标：评估协程的创建、销毁和恢复开销。

### 1. 协程创建和销毁

| 操作 | 延迟 (ns) | 吞吐量 (ops/sec) | 测试状态 |

测试协程的创建、恢复和销毁开销。|-----------|--------------|----------------------|----------|

| Task 创建 | - | - | 待测试 |

**测试代码**:| Task 销毁 | - | - | 待测试 |

```cpp| Task 带恢复 | - | - | 待测试 |

// benchmarks/task_benchmark.cpp

static void BM_TaskCreation(benchmark::State& state) {### 上下文切换性能

    for (auto _ : state) {

        auto task = []() -> Task<int> {测试目标：评估协程切换的开销及嵌套性能。

            co_return 42;

        }();| 场景 | 延迟 (ns) | 说明 | 测试状态 |

        benchmark::DoNotOptimize(task);|----------|--------------|-------|----------|

    }| 简单挂起/恢复 | - | 单个协程 | 待测试 |

}| 嵌套 co_await | - | 两层嵌套 | 待测试 |

BENCHMARK(BM_TaskCreation);| 深度嵌套 (10 层) | - | 线性开销 | 待测试 |

```

### 与其他方案对比

**当前结果**: 待测试

测试目标：与传统线程方案对比，验证协程优势。

**目标**: < 100ns

| 方案 | 上下文切换延迟 (ns) | 创建开销 (ns) | 测试状态 |

---|------|-------------------|--------------|----------|

| ZLCoro 协程 | - | - | 待测试 |

### 2. 协程切换| pthread | ~1,500 | ~25,000 | 参考值 |

| std::thread | - | ~25,000 | 参考值 |

测试协程挂起和恢复的开销。

**预期性能目标**：

**测试代码**:- 协程切换延迟 < 100 ns

```cpp- 比 pthread 快 10 倍以上

Task<void> ping_pong(int count) {- 比线程创建快 100 倍以上

    for (int i = 0; i < count; ++i) {

        co_await schedule();## 调度器性能测试

    }

}### 线程池调度器吞吐量



static void BM_ContextSwitch(benchmark::State& state) {测试目标：评估不同工作线程数下的任务吞吐量和延迟。

    for (auto _ : state) {

        ping_pong(1000).sync_wait();| 工作线程数 | 任务/秒 | CPU 使用率 | 延迟 p50 (µs) | 延迟 p99 (µs) | 测试状态 |

    }|---------|-----------|-----------|--------------|--------------|----------|

}| 1 | - | - | - | - | 待测试 |

BENCHMARK(BM_ContextSwitch);| 2 | - | - | - | - | 待测试 |

```| 4 | - | - | - | - | 待测试 |

| 8 | - | - | - | - | 待测试 |

**当前结果**: 待测试| 16 | - | - | - | - | 待测试 |



**目标**: < 50ns/switch**预期目标**：

- 单线程吞吐量 > 1M tasks/sec

---- 多线程近似线性扩展

- p99 延迟 < 100 µs

### 3. Generator 性能

### 工作窃取效率

测试生成器的迭代开销。

测试目标：评估工作窃取机制的负载均衡效果。

**测试代码**:

```cpp| 场景 | 窃取率 (%) | 负载均衡得分 | 测试状态 |

Generator<int> range(int n) {|----------|------------|-------------------|----------|

    for (int i = 0; i < n; ++i) {| 均匀任务 | - | - | 待测试 |

        co_yield i;| 倾斜任务 | - | - | 待测试 |

    }| 突发工作负载 | - | - | 待测试 |

}

**评估指标**：

static void BM_Generator(benchmark::State& state) {- 窃取率：工作窃取发生的比例

    for (auto _ : state) {- 负载均衡得分：0-1，越接近 1 表示负载越均衡

        int sum = 0;

        for (int val : range(1000)) {### I/O 调度器性能

            sum += val;

        }测试目标：评估基于 Epoll 的 I/O 调度器性能。

        benchmark::DoNotOptimize(sum);

    }#### Echo 服务器基准测试

}

BENCHMARK(BM_Generator);| 连接数 | QPS | 延迟 p50 (µs) | 延迟 p99 (µs) | CPU 使用率 | 测试状态 |

```|-------------|-----|------------------|------------------|-----------|----------|

| 100 | - | - | - | - | 待测试 |

**当前结果**: 待测试| 1K | - | - | - | - | 待测试 |

| 10K | - | - | - | - | 待测试 |

**目标**: 接近手写循环| 100K | - | - | - | - | 待测试 |



---**预期目标**：

- 10K 连接 QPS > 500K

### 4. 并发任务调度- p99 延迟 < 2 ms

- CPU 使用率 < 90%

测试调度器的并发性能。

## 内存使用测试

**测试代码**:

```cpp### 每协程开销

static void BM_Scheduler(benchmark::State& state) {

    int num_tasks = state.range(0);测试目标：评估单个协程的内存占用。

    

    for (auto _ : state) {| 组件 | 大小 (字节) | 测试状态 |

        std::vector<std::future<void>> futures;|-----------|--------------|----------|

        for (int i = 0; i < num_tasks; ++i) {| 协程帧 (最小) | - | 待测试 |

            futures.push_back(async_run(simple_task()));| Task<void> | - | 待测试 |

        }| Task<int> | - | 待测试 |

        for (auto& f : futures) {| Promise 开销 | - | 待测试 |

            f.get();

        }### 调度器内存

    }

}测试目标：评估调度器组件的内存占用。

BENCHMARK(BM_Scheduler)->Range(1, 10000);

```| 组件 | 内存使用 | 可扩展性 | 测试状态 |

|-----------|--------------|-------------|----------|

**当前结果**: 待测试| 线程池 (8 工作线程) | - | O(num_threads) | 待测试 |

| I/O 调度器 | - | O(1) 基础 | 待测试 |

**目标**: 线性扩展到 CPU 核心数| 定时器轮 | - | O(1) | 待测试 |

| 每连接状态 | - | O(connections) | 待测试 |

---

### 大规模内存测试

### 5. 文件 I/O

测试目标：评估百万级协程的内存扩展性。

测试异步文件操作的吞吐量。

| 并发协程数 | 内存 (GB) | 内存/协程 (KB) | 测试状态 |

**测试代码**:|----------------------|-------------|----------------------|----------|

```cpp| 10K | - | - | 待测试 |

static void BM_FileIO(benchmark::State& state) {| 100K | - | - | 待测试 |

    size_t file_size = state.range(0);| 1M | - | - | 待测试 |

    std::string data(file_size, 'x');| 10M | - | - | 待测试 |

    

    for (auto _ : state) {**预期目标**：

        auto task = [&]() -> Task<void> {- 每协程内存 < 2 KB

            co_await write_file("/tmp/bench.txt", data);- 内存/协程比例保持稳定

            std::string content = co_await read_file("/tmp/bench.txt");

            benchmark::DoNotOptimize(content);## 同步原语测试

        };

        async_run(task()).get();### Mutex 性能

    }

    测试目标：评估协程 Mutex 在不同竞争场景下的性能。

    state.SetBytesProcessed(state.iterations() * file_size * 2);

}| 场景 | 加锁/解锁 (ns) | 吞吐量 (ops/sec) | 测试状态 |

BENCHMARK(BM_FileIO)->Range(1024, 1024*1024*10);|----------|------------------|----------------------|----------|

```| 无竞争 | - | - | 待测试 |

| 低竞争 (2 线程) | - | - | 待测试 |

**当前结果**: 待测试| 中竞争 (4 线程) | - | - | 待测试 |

| 高竞争 (8 线程) | - | - | 待测试 |

**目标**: > 1GB/s

### Channel 性能

---

测试目标：评估不同缓冲区大小下的 Channel 性能。

### 6. 网络 Echo 服务器

| 缓冲区大小 | 发送+接收 (ns) | 吞吐量 (msgs/sec) | 测试状态 |

测试网络 I/O 的 QPS 和延迟。|-------------|-------------------|----------------------|----------|

| 0 (无缓冲) | - | - | 待测试 |

**测试方法**:| 10 | - | - | 待测试 |

1. 启动 Echo 服务器| 100 | - | - | 待测试 |

2. 使用多个客户端并发连接| 1000 | - | - | 待测试 |

3. 发送固定大小的消息

4. 测量 QPS 和延迟**预期目标**：

- 无缓冲 Channel > 1M msgs/sec

**当前结果**: 待测试- 缓冲 Channel > 5M msgs/sec



**目标**:## I/O 操作测试

- QPS: > 100 万

- P99 延迟: < 1ms### Socket 操作



---测试目标：评估异步 Socket 的读写性能。



## 内存分析| 操作 | 延迟 (µs) | 吞吐量 | 测试状态 |

|-----------|--------------|------------|----------|

### 协程内存开销| async_read (1KB) | - | - | 待测试 |

| async_write (1KB) | - | - | 待测试 |

使用 Valgrind Massif 分析内存使用：| async_read (64KB) | - | - | 待测试 |

| async_write (64KB) | - | - | 待测试 |

```bash

valgrind --tool=massif ./benchmarks/memory_bench### 文件 I/O

ms_print massif.out.<pid>

```测试目标：评估文件异步 I/O 性能（未来实现）。



**测试场景**:| 操作 | 延迟 (µs) | 吞吐量 | 测试状态 |

1. 创建 100 万个协程|-----------|--------------|------------|----------|

2. 测量总内存使用| 异步读取 | - | - | 计划中 |

3. 计算平均内存/协程| 异步写入 | - | - | 计划中 |



**当前结果**: 待测试## 实际应用基准测试



**目标**: < 2KB/协程### HTTP 服务器



---测试目标：评估实际 HTTP 服务器性能。



## 性能对比| 指标 | 值 | 测试条件 | 测试状态 |

|--------|-------|-----------------|----------|

### 与其他框架对比| 请求/秒 | - | 1KB 静态文件 | 待测试 |

| 延迟 p50 | - | 1K 连接 | 待测试 |

| 框架 | 协程创建 | 上下文切换 | 内存开销 | Echo QPS || 延迟 p99 | - | 1K 连接 | 待测试 |

|------|---------|-----------|---------|---------|| 最大连接数 | - | 8GB 内存限制 | 待测试 |

| ZLCoro | 待测试 | 待测试 | 待测试 | 待测试 |

| cppcoro | ~100ns | ~50ns | ~2KB | N/A |**预期目标**：

| libco | ~80ns | ~40ns | 1KB | 100万+ |- 请求/秒 > 100K

| Seastar | ~120ns | ~60ns | ~3KB | 200万+ |- p99 延迟 < 2 ms

- 最大连接数 > 50K

---

### JSON-RPC 服务器

## 性能优化建议

测试目标：评估 RPC 服务器性能。

### 编译优化

| 指标 | 值 | 测试条件 | 测试状态 |

```bash|--------|-------|-----------------|----------|

# Release 构建| 请求/秒 | - | 简单方法调用 | 待测试 |

cmake -DCMAKE_BUILD_TYPE=Release ..| 延迟 p50 | - | 1K 连接 | 待测试 |

| 延迟 p99 | - | 1K 连接 | 待测试 |

# 启用 LTO

cmake -DCMAKE_INTERPROCEDURAL_OPTIMIZATION=ON ..## 与业界框架对比



# 使用 Clang### vs. Go Goroutines

export CC=clang CXX=clang++

cmake ..测试目标：与 Go 语言协程对比。

```

| 指标 | ZLCoro | Go 1.21+ | 对比 | 测试状态 |

### 运行时优化|--------|--------|---------|-----------|----------|

| 创建时间 (ns) | - | ~2,500 | - | 待测试 |

1. **线程数调优**: 设置为 CPU 核心数| 上下文切换 (ns) | - | ~200 | - | 待测试 |

2. **批量操作**: 减少系统调用| 内存/协程 (KB) | - | ~2.0 | - | 待测试 |

3. **零拷贝**: 使用 `std::string_view`| 最大并发数 | - | 10M+ | - | 待测试 |

4. **内存池**: 重用协程状态

### vs. Rust Tokio

---

测试目标：与 Rust 异步运行时对比。

## 分析工具

| 指标 | ZLCoro | Tokio 1.32+ | 对比 | 测试状态 |

### perf|--------|--------|------------|-----------|----------|

| 任务创建 (ns) | - | ~150 | - | 待测试 |

CPU 性能分析：| Channel 发送 (ns) | - | ~95 | - | 待测试 |

| I/O 吞吐量 (QPS) | - | ~580K | - | 待测试 |

```bash

perf record -g ./your_program### vs. C++ 异步库

perf report

```测试目标：与其他 C++ 异步框架对比。



### Valgrind| 框架 | 连接数 | QPS | 延迟 p99 (µs) | 测试状态 |

|-----------|-------------|-----|------------------|----------|

内存泄漏检测：| ZLCoro | 10K | - | - | 待测试 |

| libuv | 10K | ~380K | ~1,800 | 参考值 |

```bash| Boost.Asio | 10K | ~420K | ~1,500 | 参考值 |

valgrind --leak-check=full ./your_program| 原生 epoll | 10K | ~550K | ~1,100 | 参考值 |

```

## 优化效果测试

### AddressSanitizer

### 缓存优化

内存错误检测：

测试目标：评估缓存优化的效果。

```bash

cmake -DCMAKE_CXX_FLAGS="-fsanitize=address" ..| 优化项 | 优化前 (ns) | 优化后 (ns) | 提升 (%) | 测试状态 |

```|--------------|-------------|------------|----------|----------|

| 数据对齐 | - | - | - | 待测试 |

---| 缓存友好布局 | - | - | - | 待测试 |

| 移除伪共享 | - | - | - | 待测试 |

## 待办事项

### 无锁算法

- [ ] 实现所有基准测试

- [ ] 收集基准数据测试目标：评估无锁算法的性能提升。

- [ ] 与其他框架对比

- [ ] 性能优化| 组件 | 加锁版本 (ns) | 无锁版本 (ns) | 提升 (%) | 测试状态 |

- [ ] 持续集成性能测试|-----------|-------------|----------------|----------|----------|

| 工作队列 push | - | - | - | 待测试 |

---| 工作队列 steal | - | - | - | 待测试 |



## 参考资料## 可扩展性分析



- [Google Benchmark](https://github.com/google/benchmark)### CPU 扩展性

- [Linux perf](https://perf.wiki.kernel.org/)

- [Valgrind](https://valgrind.org/)测试目标：评估多核扩展性能。



---| 核心数 | 吞吐量 | 扩展效率 (%) | 测试状态 |

|--------|--------|------------|----------|

## 相关文档| 1 | - | 100% | 待测试 |

| 2 | - | - | 待测试 |

- [架构设计](ARCHITECTURE.md)| 4 | - | - | 待测试 |

- [API 参考](API.md)| 8 | - | - | 待测试 |

- [项目进度](../PROGRESS.md)| 16 | - | - | 待测试 |


**分析重点**：
- 识别扩展瓶颈
- 评估是否存在内存带宽限制
- 检测缓存一致性开销
- NUMA 效应（多插槽系统）

### 内存扩展性

测试目标：评估内存使用的可预测性。

**关注指标**：
- 每协程内存开销的稳定性
- 内存池化效果
- 内存碎片情况
- GC-less 设计的优势

## 测试状态说明

| 状态 | 说明 |
|------|------|
| ✅ 已完成 | 测试已完成，数据已验证 |
| 🚧 进行中 | 正在进行测试 |
| 待测试 | 等待功能实现后测试 |
| 计划中 | 未来版本计划测试 |
| 参考值 | 业界参考数据，非实测 |

## 测试优先级

### P0 - 核心功能（v0.2.0）
- [ ] Task 创建/销毁性能
- [ ] 协程上下文切换
- [ ] 线程池调度器吞吐量
- [ ] 基本内存使用

### P1 - I/O 性能（v0.3.0）
- [ ] Echo 服务器基准测试
- [ ] Socket 读写性能
- [ ] I/O 调度器性能
- [ ] 大规模连接测试

### P2 - 同步原语（v0.4.0）
- [ ] Mutex 性能
- [ ] Channel 性能
- [ ] WaitGroup/Semaphore

### P3 - 优化验证（v0.5.0）
- [ ] 缓存优化效果
- [ ] 无锁算法性能
- [ ] CPU/内存扩展性

### P4 - 对比测试（v1.0.0）
- [ ] 与 Go/Rust 对比
- [ ] 与其他 C++ 库对比
- [ ] 实际应用场景测试

## 持续集成

所有基准测试将在 CI 中自动运行，监控性能回归：

- **触发条件**: 每次 PR 提交
- **回归检测**: 性能下降 > 5% 将触发警告
- **趋势分析**: 长期性能趋势可视化
- **报告生成**: 自动生成性能报告

---

**文档状态**: 测试计划中  
**最后更新**: 2025-11-07  
**下次更新**: 核心功能实现后

如有测试方法或指标建议，请在 GitHub Issues 中讨论。
